在Java中，`hashCode()` 和 `equals()` 方法之间存在紧密的关系，尤其是在基于哈希的集合（如 `HashMap`、`HashSet`）中。它们之间的关系由Java的**哈希约定**定义。以下是这两者的主要关系：

### 1. **基本原则**：
   - **equals() 相等时，hashCode() 必须相等**：如果两个对象通过`equals()`方法判断为相等，则它们的`hashCode()`值必须相同。这是为了确保在哈希结构中能够正确存储和查找对象。
   - **hashCode()相等时，equals() 不一定相等**：如果两个对象的`hashCode()`相等，它们不一定在`equals()`方法下相等。多个不相等的对象可以共享相同的哈希码，但这在哈希表中会导致哈希冲突，影响性能。

### 2. **哈希表中的作用**：
   - 当对象被放入哈希表（如`HashSet`、`HashMap`）时，Java会首先调用对象的`hashCode()`方法以确定对象应存放的“桶”（bucket）。在同一“桶”中的对象可能有多个，`equals()`方法则用于在这个“桶”中进一步比较对象是否相等。
   - 如果`hashCode()`不一致，那么即使`equals()`相等也无法确保对象存储在正确的“桶”中，这会破坏哈希结构的正确性。

### 3. **关系总结**：
   - `hashCode()` 用于快速查找对象的存储位置，`equals()` 则用于在相同位置的对象之间进行进一步比较。
   - 重写`equals()`时，必须遵循与`hashCode()`的一致性，即确保相等的对象具有相同的哈希码，否则可能会出现哈希结构中的问题，如无法正确查找到对象。

### 4. **Java中的合同**：
   Java对`equals()` 和 `hashCode()` 的合同可以总结为：
   1. 如果两个对象通过`equals()`判断为相等，则它们的`hashCode()`必须相等。
   2. 如果两个对象的`hashCode()`不相等，则它们一定是不相等的对象。
   3. 如果两个对象的`hashCode()`相等，它们未必通过`equals()`判断为相等（可能存在哈希冲突）。

这两者的正确实现对于保证哈希集合的高效性和正确性非常关键。
