**Java泛型擦除**（Generic Type Erasure）是指在编译过程中，Java的泛型类型信息会被移除（即“擦除”），并在运行时不再保留具体的泛型类型。这是因为Java泛型是为向后兼容而设计的，它们只在编译时检查类型，在运行时并不会携带实际的类型信息。

### 泛型擦除的工作原理：
1. **类型参数替换为上限类型**：编译器会将泛型类型替换为它的上限类型。如果没有明确的上限，默认使用 `Object` 作为上限。例如：
   ```java
   public class Box<T> {
       private T item;
   }
   ```
   在编译后，这个类会被转换为：
   ```java
   public class Box {
       private Object item;
   }
   ```

2. **移除泛型类型信息**：在编译过程中，所有的泛型类型信息都会被移除，Java运行时无法获取具体的类型。例如：
   ```java
   List<String> list = new ArrayList<>();
   ```
   编译后的代码会变成：
   ```java
   List list = new ArrayList();
   ```

3. **类型转换**：编译器会在适当的地方插入类型转换操作，以确保类型安全。例如：
   ```java
   String s = list.get(0);
   ```
   编译器会插入类型转换：
   ```java
   String s = (String) list.get(0);
   ```

### 泛型擦除的限制：
由于泛型类型在运行时被擦除，Java中的泛型有一些限制：
- **不能创建泛型类的实例**：
  ```java
  T obj = new T();  // 编译错误
  ```
  泛型在编译时被擦除，无法在运行时确定 `T` 的实际类型。
  
- **不能使用基本类型作为泛型参数**：因为泛型擦除后只能使用对象类型，Java的基本类型（如 `int`、`char` 等）不能直接作为泛型的类型参数使用，必须使用其包装类（如 `Integer`、`Character`）。

- **不能使用泛型创建数组**：
  ```java
  List<String>[] listArray = new ArrayList<String>[10];  // 编译错误
  ```

### 类型擦除的影响：
1. **运行时的类型信息丢失**：由于泛型类型在运行时被擦除，Java的反射机制无法获取泛型的具体类型信息。这意味着你无法在运行时通过反射判断泛型的具体类型。
2. **泛型方法的重载限制**：由于类型擦除的缘故，无法对泛型参数进行方法重载，因为在擦除后它们被视为相同的参数类型。例如，以下两个方法在编译时会被认为是重复定义的：
   ```java
   public void method(List<String> list) { }
   public void method(List<Integer> list) { }
   ```

### 总结：
泛型擦除是Java实现泛型的一种机制，它保证了与非泛型代码的兼容性，但也导致了一些运行时类型检查的局限性。在编译阶段，泛型提供类型检查和安全性，但在运行时，所有的类型信息都被擦除，只剩下上限类型（通常是 `Object`）。

通过这种方式，Java保证了泛型的类型安全，但避免了在运行时管理类型信息的复杂性。
