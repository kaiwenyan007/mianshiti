在 Java 中，**CMS（Concurrent Mark-Sweep）** 和 **G1（Garbage First）** 垃圾收集器通过不同的策略来维持并发操作的正确性。并发垃圾收集器的挑战在于如何在垃圾收集与应用程序线程（Mutator）同时运行的情况下，确保不破坏内存的一致性并正确识别存活对象。

### 1. **CMS（Concurrent Mark-Sweep）垃圾收集器的并发正确性维护**

CMS 主要通过以下步骤和机制来确保并发正确性：

#### a. **标记阶段**
   - **初始标记（Initial Mark）**：
     - 这是一个短暂停顿阶段，CMS 会扫描 GC Roots（例如全局变量、线程栈等），标记从这些根对象直接可达的对象。
     - 这一阶段是“Stop-the-World”（STW）的，但停顿时间较短。
   
   - **并发标记（Concurrent Mark）**：
     - 这一阶段与应用程序线程并发进行。CMS 从初始标记阶段的对象开始，递归标记所有可达对象。
     - 由于应用线程在运行过程中可能会更新对象引用，CMS 需要跟踪这些变化。

#### b. **并发正确性机制**
   - **写屏障（Write Barrier）**：
     - 为了确保并发标记过程中对象引用关系的变化不会导致存活对象的遗漏，CMS 使用“增量更新”策略。在对象引用发生变化时，CMS 会通过写屏障记录这些变化。
     - 具体来说，每当一个对象的引用被修改，CMS 会将其标记为“脏”，在后续标记阶段重新扫描这些“脏”对象，确保引用关系的正确性。

   - **重新标记（Remark）**：
     - 由于并发标记期间引用关系可能发生变化，CMS 在并发标记之后进行“重新标记”（STW），再次暂停应用线程，扫描那些在并发标记期间被修改过的对象，确保没有遗漏任何可达对象。

#### c. **并发清除（Concurrent Sweep）**
   - 标记阶段完成后，CMS 会并发执行清理阶段，回收不可达对象的内存空间。这一阶段不会影响应用程序的正常执行。

#### CMS 的并发正确性挑战：
   - **浮动垃圾**：CMS 在并发清除过程中，应用程序仍在分配内存，因此会出现一部分已死对象在本次回收中未能清理，它们会被称为“浮动垃圾”，并将在下一次垃圾回收时处理。
   - **STW 停顿**：虽然 CMS 是并发垃圾回收，但它仍然有两次 STW 停顿（初始标记和重新标记阶段），这可能会影响延迟敏感的应用。

---

### 2. **G1（Garbage First）垃圾收集器的并发正确性维护**

G1 引入了更加复杂和高效的并发处理机制，以提高并发垃圾回收的准确性和性能。G1 的并发正确性依赖于以下几点：

#### a. **标记阶段**
   - **初始标记（Initial Mark）**：
     - 与 CMS 类似，G1 的初始标记也是 STW 阶段，但它会在一次 Minor GC 之后顺便进行，因此停顿时间很短。
   
   - **并发标记（Concurrent Mark）**：
     - 与应用线程并发进行。G1 遍历堆中所有的 Region，标记存活对象。此时应用线程可以继续分配和修改引用。

#### b. **并发正确性机制**
   - **写屏障（Write Barrier）**：
     - G1 使用“SATB（Snapshot-At-The-Beginning）”技术，通过写屏障在标记阶段维护对象引用的一致性。
     - SATB 机制会记录对象引用的**旧值**。当应用线程在并发标记期间修改对象引用时，SATB 会将修改前的对象记录下来，以确保在垃圾回收时仍能扫描这些旧的对象，避免遗漏可达对象。
     - **增量更新**：G1 通过增量地维护对象引用关系，以减少标记阶段的复杂性。

   - **最终标记（Remark）**：
     - 与 CMS 类似，G1 在并发标记阶段之后也有一个短暂的 STW 阶段，来确保对所有对象引用关系的重新扫描（Remark），保证引用更新期间不会遗漏存活对象。
   
#### c. **并发清理（Concurrent Cleanup）**
   - G1 进行并发清理时，通过标记的记忆集（RSet）可以精准地回收垃圾对象，并能同时允许应用程序继续运行。

#### d. **Mixed GC**：
   - G1 的一大特点是它会在新生代的 Minor GC 之后，结合对部分老年代的回收（Mixed GC），通过并发标记，准确收集那些占用较多垃圾的 Region，避免全堆扫描。

#### G1 的并发正确性优势：
   - **更少的停顿**：G1 通过 SATB 技术和细粒度的 Region 管理，在标记和回收过程中减少了停顿时间和全堆扫描。
   - **更高的并发性**：G1 可以精确地回收部分老年代，而不是一次性回收整个老年代，进一步减少了 Full GC 的频率，提升了应用的吞吐量和延迟表现。

---

### 总结：
- **CMS**：通过增量更新和写屏障确保标记阶段引用更新的正确性，但仍需要两次 STW 阶段（初始标记和重新标记）。CMS 主要的问题是可能产生“浮动垃圾”，并且在并发清理过程中，堆内存会逐渐填满，导致性能下降。
  
- **G1**：通过 SATB 和更精确的 Region 管理来确保并发标记的正确性，并减少 STW 停顿。G1 的 Mixed GC 和 SATB 技术使得它能在大型堆和高并发应用中表现得更加稳定。

G1 相比 CMS，在并发回收的正确性和效率上有更明显的优势，特别是在大规模堆和复杂应用中，G1 具有更好的延迟控制和吞吐性能。需要进一步深入探讨 G1 或 CMS 的某些细节吗？
