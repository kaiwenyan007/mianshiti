**CMS（Concurrent Mark-Sweep）垃圾回收器**是 Java 中的一种低停顿、以减少应用程序停顿时间为目标的垃圾回收器，特别适用于对响应时间敏感的应用。CMS 是一种并发垃圾收集器，它可以与应用线程同时运行，从而减少垃圾回收时的停顿时间。CMS 主要用于**老年代**（Old Generation）的垃圾回收。

### CMS 垃圾回收器的基本原理：
CMS 采用 **“标记-清除”（Mark-Sweep）** 算法来回收垃圾。它的主要流程分为以下四个阶段：

### 1. **初始标记（Initial Mark）**
   - **特点**：Stop-The-World（STW），短暂停顿。
   - **操作**：
     - 初始标记阶段，CMS 垃圾回收器从**GC Roots** 开始，标记所有直接可达的对象。
     - GC Roots 通常包括线程栈中的对象、类静态字段和全局对象等。
   - **停顿时间**：因为仅需标记 GC Roots，时间相对较短。

### 2. **并发标记（Concurrent Mark）**
   - **特点**：与应用线程并发执行。
   - **操作**：
     - CMS 从初始标记阶段找到的存活对象开始递归扫描，标记所有可达的对象。
     - 这一过程与应用程序线程并发执行，应用程序仍然可以修改对象的引用。
     - 由于应用线程仍在运行，可能会在标记期间更改对象的引用关系，CMS 需要额外的机制来确保标记的准确性（通过写屏障机制跟踪引用更新）。
   - **目标**：尽量减少应用程序的停顿时间。

### 3. **重新标记（Remark）**
   - **特点**：Stop-The-World（STW），较长时间的停顿。
   - **操作**：
     - 由于并发标记期间应用程序线程可能会修改对象引用关系，CMS 需要在这个阶段暂停所有应用线程，重新标记那些在并发标记过程中发生变化的对象。
     - CMS 通过之前的写屏障机制记录了对象引用的变化，并在重新标记阶段对这些变化进行扫描，确保没有遗漏存活的对象。
   - **停顿时间**：比初始标记稍长，但仍然相对较短。

### 4. **并发清除（Concurrent Sweep）**
   - **特点**：与应用线程并发执行，无需停顿。
   - **操作**：
     - CMS 识别出标记阶段未被标记为存活的对象，并回收这些不可达对象的内存。
     - 这一过程与应用程序线程并发进行，不会造成停顿。
     - 清除阶段不会对内存进行压缩（即不会进行内存整理），因此可能会产生**内存碎片**。
   
### CMS 的工作流程总结：
- **初始标记** 和 **重新标记** 阶段会暂停应用线程，但时间较短，停顿时间远低于传统的**Stop-The-World（STW）** 垃圾收集器（如 Serial 或 Parallel GC）。
- **并发标记** 和 **并发清除** 阶段与应用线程并发运行，减少了对应用程序性能的影响。
  
---

### CMS 垃圾回收器的优点：
1. **低停顿**：CMS 的设计目标是尽可能减少 GC 过程中应用程序的停顿时间，尤其是在老年代回收时。
2. **并发性**：CMS 的主要操作是与应用线程并发执行的，能够在应用程序运行的同时进行垃圾回收工作，尤其适合对响应时间敏感的应用。
3. **老年代回收的并发性**：传统的垃圾回收器在回收老年代时需要进行全堆扫描，并会导致较长时间的 STW 停顿，而 CMS 通过并发标记和清除来减少这种停顿。

---

### CMS 垃圾回收器的缺点：
1. **内存碎片**：CMS 使用的是“标记-清除”算法，它不会对内存进行整理（即不会进行内存压缩），因此可能会导致内存碎片。如果堆空间中存在大量的碎片，可能导致后续内存分配失败，从而触发 Full GC。
2. **浮动垃圾**：由于 CMS 与应用线程并发运行，可能在并发清除阶段产生**浮动垃圾**。浮动垃圾是指在 CMS 标记存活对象之后、并发清除阶段之前被释放的对象，这部分垃圾无法在当前回收周期中被处理，必须等到下一次 GC 才能回收。
3. **Concurrent Mode Failure**：CMS 在并发清除阶段依赖堆内存中有足够的空闲空间。如果应用程序在并发清除期间继续快速分配内存，可能导致内存不足，从而触发 Full GC（即 Stop-The-World 的垃圾回收）。这称为“并发模式失败”（Concurrent Mode Failure），会导致长时间的停顿。
4. **更高的 CPU 资源消耗**：由于 CMS 与应用程序线程并发执行，它会占用一定的 CPU 资源，可能会影响应用程序的吞吐量。

---

### CMS 关键参数配置：
CMS 垃圾回收器可以通过多种 JVM 参数进行配置，以下是一些常见的配置项：

- `-XX:+UseConcMarkSweepGC`：启用 CMS 垃圾收集器。
- `-XX:CMSInitiatingOccupancyFraction=<N>`：当老年代的使用率达到 N% 时，开始触发 CMS 回收，默认值为 68%。
- `-XX:+UseCMSInitiatingOccupancyOnly`：仅根据 `CMSInitiatingOccupancyFraction` 配置的阈值来触发 CMS，而不是使用 JVM 自适应的触发机制。
- `-XX:+CMSParallelRemarkEnabled`：启用并行重新标记，进一步减少 `remark` 阶段的停顿时间。
- `-XX:ParallelGCThreads=<N>`：指定 CMS 使用的并发线程数。

---

### CMS 的整体工作流程：

1. **初始标记**（短暂停顿） → 2. **并发标记**（应用程序线程和标记同时进行） → 3. **重新标记**（短暂停顿） → 4. **并发清除**（应用程序线程和垃圾回收同时进行）

CMS 的设计目标是通过并发标记和清除来减少应用程序的停顿时间，但在一定条件下（如内存碎片过多或并发模式失败）可能仍会导致 Full GC。因此，CMS 适用于需要低停顿、并发性强的应用场景，但它在内存管理上不如 G1 垃圾收集器先进，特别是在处理内存碎片和全堆整理方面。G1 垃圾回收器逐渐替代了 CMS，成为现代 JVM 的默认收集器。

你对 CMS 或其配置有其他问题吗？
