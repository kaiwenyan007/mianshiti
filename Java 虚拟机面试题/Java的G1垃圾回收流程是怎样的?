Java 的 **G1（Garbage First）垃圾回收器** 是一种设计用于大堆内存、低停顿的垃圾回收器，它在 JVM 中替代了 CMS（Concurrent Mark-Sweep）收集器，解决了 CMS 的一些性能瓶颈。G1 通过将堆划分为多个相同大小的区域（Regions），对垃圾回收进行更加灵活的管理，能够同时回收新生代和老年代的垃圾。

### G1 垃圾回收的核心特点：
1. **堆划分为 Region**：
   - G1 将整个堆划分为多个大小相同的区域（Regions），每个 Region 可以属于新生代（Eden、Survivor）或老年代。
   - 每个 Region 的大小是固定的，一般是 1MB 到 32MB，具体取决于堆大小。

2. **Region 内存布局**：
   - 堆中的对象根据生命周期存储在不同的 Region。
   - Eden、Survivor 区域用于新生代，老年代用于存放存活时间较长的对象。
   - 每个 Region 可以动态改变用途，G1 通过回收尽量多的 Region 来最大化空间利用率。

3. **混合回收（Mixed GC）**：
   - G1 的一个核心优势是能混合回收新生代和部分老年代（Mixed GC），避免 CMS 的全堆扫描。

---

### G1 垃圾回收的流程

G1 的垃圾回收主要分为两种类型：**Young GC（针对新生代）** 和 **Mixed GC（混合回收新生代和老年代）**。其整体流程可以归纳为以下几个主要阶段：

### 1. **Young GC（新生代回收）**
   Young GC 是针对新生代（Eden 和 Survivor 区域）的垃圾回收过程，类似于传统的 Minor GC。

   - **触发条件**：当 Eden 区填满时，触发 Young GC。
   - **过程**：
     1. Eden 中的对象被回收。
     2. 存活对象被复制到 Survivor 区或者提升到老年代（如果对象的年龄达到了阈值）。
     3. 整个过程是“Stop-the-World”（STW）的，但停顿时间相对较短。
  
   Young GC 的主要目标是快速回收短生命周期的对象。

### 2. **并发标记（Concurrent Marking）**
   这个阶段负责标记堆中存活的老年代对象，作为 Mixed GC 的基础。

   - **初始标记（Initial Mark）**：
     1. 这是一个短暂的 STW 阶段，G1 会标记 GC Roots 直接引用的对象。
     2. 初始标记通常和一次 Young GC 结合在一起执行，以减少停顿时间。

   - **并发标记（Concurrent Mark）**：
     1. 这是 G1 的并发阶段，它与应用程序线程并发执行。
     2. 垃圾收集器从初始标记的对象开始，递归扫描整个堆中的存活对象。
     3. G1 使用 **SATB（Snapshot-At-The-Beginning）** 算法，通过写屏障机制记录在并发标记期间引用的变化，保证标记结果的准确性。

   - **最终标记（Remark）**：
     1. 这是一个短暂的 STW 阶段，G1 会重新扫描 GC Roots 以及在并发标记期间对象引用发生变化的部分。
     2. 确保没有遗漏任何存活对象。

   - **清理（Cleanup）**：
     1. 这个阶段会识别哪些 Region 可以被回收，并准备执行 Mixed GC。
     2. 清理阶段可以是并发的，也可以是 STW 的，具体取决于是否涉及内存回收操作。

### 3. **Mixed GC（混合回收）**
   Mixed GC 是 G1 的一个重要特点，除了新生代的回收，它还会同时回收一部分老年代区域。

   - **触发条件**：Mixed GC 通常在并发标记完成之后触发，并会持续执行多次，直到足够多的老年代 Region 被回收。
   - **过程**：
     1. 首先回收新生代的 Eden 和 Survivor 区域（类似 Young GC）。
     2. 其次，根据并发标记的结果，回收老年代中含有较多垃圾的 Region。
     3. G1 的目标是通过回收**垃圾比例最高的 Region**，即 Garbage First，来提高回收效率。
   
   Mixed GC 是 G1 的一个重要优化，它避免了老年代一次性 Full GC 的高停顿，减少了老年代对象回收的代价。

### 4. **Full GC（完全垃圾回收）**
   如果 G1 无法回收足够的内存或内存碎片过多，可能会触发 Full GC。

   - **过程**：
     1. Full GC 是一个 Stop-the-World 过程，会暂停所有应用线程。
     2. G1 会对整个堆进行扫描和压缩（Compaction），回收所有不可达的对象。
     3. Full GC 是 G1 的最不希望发生的情况，因为它的停顿时间较长。

---

### G1 的垃圾回收机制总结
G1 的垃圾回收流程旨在减少全堆扫描和长时间的停顿，通过以下几项关键技术提高效率：

1. **Region 划分**：通过将堆划分为多个 Region，G1 可以有选择性地回收含有较多垃圾的 Region。
2. **混合回收（Mixed GC）**：在并发标记后，G1 通过 Mixed GC 回收老年代的垃圾，避免一次性回收整个老年代。
3. **并发标记**：G1 能并发标记老年代存活对象，与应用线程同时工作，减少应用程序停顿。
4. **SATB（Snapshot-At-The-Beginning）**：写屏障机制帮助 G1 在并发标记时维护引用的正确性，防止垃圾回收过程中丢失存活对象。
5. **目标停顿时间**：G1 可以根据设置的最大停顿时间目标（通过 `-XX:MaxGCPauseMillis`）动态调整回收的行为，确保在给定的停顿时间内尽可能多地回收垃圾。

这些特性使得 G1 能在大堆内存场景下有效控制 GC 停顿时间，提供较低的延迟和较高的吞吐量。

你还想了解哪一部分的细节呢？
