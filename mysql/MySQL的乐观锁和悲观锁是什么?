在 MySQL 中，**乐观锁**和**悲观锁**是两种常见的并发控制策略，用于处理多线程环境中的数据一致性问题。以下是它们的详细解释和区别：

### 悲观锁（Pessimistic Locking）

- **定义**：悲观锁假设会发生冲突，因此在读取数据时立即加锁，防止其他事务修改同一数据。这种策略对数据的并发访问采取了一种“悲观”的态度。
- **实现方式**：
  - 使用行级锁或表级锁，通常在 SQL 查询中使用 `SELECT ... FOR UPDATE` 或 `LOCK TABLES`。
- **优点**：
  - 确保数据一致性，避免数据冲突。
  - 对于读写频繁且竞争激烈的场景比较有效。
- **缺点**：
  - 降低了系统的并发性能，因为锁会导致其他事务被阻塞。
  - 锁的管理和释放增加了系统的复杂性，可能导致死锁。

### 乐观锁（Optimistic Locking）

- **定义**：乐观锁假设不会发生冲突，因此在读取数据时不加锁。在更新数据时，通过检查版本号或时间戳来判断数据是否被其他事务修改。
- **实现方式**：
  - 通常在数据表中添加一个版本字段或时间戳字段。
  - 更新时，通过版本号检查，只有当版本号匹配时才允许更新。
  - 例如：`UPDATE table SET value = newValue, version = version + 1 WHERE id = ? AND version = oldVersion`。
- **优点**：
  - 提高了系统的并发性能，因为在没有冲突时不需要加锁。
  - 锁的开销较小，减少了死锁的风险。
- **缺点**：
  - 在高竞争场景下，如果频繁发生冲突，可能会导致大量的重试操作，降低性能。
  - 对于一些业务场景，需要手动管理版本号，增加了复杂性。

### 总结

| 特性                | 悲观锁                           | 乐观锁                           |
|---------------------|----------------------------------|----------------------------------|
| 假设冲突            | 是                               | 否                               |
| 数据读取时加锁     | 是                               | 否                               |
| 更新时检查          | 无                               | 版本号或时间戳检查             |
| 性能影响            | 降低并发性能                     | 提高并发性能                     |
| 适用场景            | 高竞争、频繁读写                 | 低竞争、读多写少                 |

### 适用场景

- **悲观锁**：适用于读写频繁、竞争激烈的场景，比如银行转账等需要强一致性的事务。
- **乐观锁**：适用于读操作多于写操作、并发冲突较少的场景，比如某些业务查询和批量更新。
